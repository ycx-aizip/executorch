// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_QCIR_QCIR_H_
#define FLATBUFFERS_GENERATED_QCIR_QCIR_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 24 &&
              FLATBUFFERS_VERSION_MINOR == 3 &&
              FLATBUFFERS_VERSION_REVISION == 25,
             "Non-compatible flatbuffers version included");

namespace qcir {

struct ScaleOffset;

struct QuantizeParam;
struct QuantizeParamBuilder;

struct Tensor;
struct TensorBuilder;

struct Operator;
struct OperatorBuilder;

struct Graph;
struct GraphBuilder;

struct Context;
struct ContextBuilder;

enum class TensorType : int8_t {
  WRITE = 0,
  READ = 1,
  READWRITE = 2,
  NATIVE = 3,
  STATIC = 4,
  OPTIONAL = 5,
  UNDEFINED = 6,
  MIN = WRITE,
  MAX = UNDEFINED
};

inline const TensorType (&EnumValuesTensorType())[7] {
  static const TensorType values[] = {
    TensorType::WRITE,
    TensorType::READ,
    TensorType::READWRITE,
    TensorType::NATIVE,
    TensorType::STATIC,
    TensorType::OPTIONAL,
    TensorType::UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesTensorType() {
  static const char * const names[8] = {
    "WRITE",
    "READ",
    "READWRITE",
    "NATIVE",
    "STATIC",
    "OPTIONAL",
    "UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameTensorType(TensorType e) {
  if (::flatbuffers::IsOutRange(e, TensorType::WRITE, TensorType::UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesTensorType()[index];
}

enum class DataType : int8_t {
  INT8 = 0,
  INT16 = 1,
  INT32 = 2,
  INT64 = 3,
  UINT8 = 4,
  UINT16 = 5,
  UINT32 = 6,
  UINT64 = 7,
  FLOAT16 = 8,
  FLOAT32 = 9,
  FLOAT64 = 10,
  SFIXED4 = 11,
  SFIXED8 = 12,
  SFIXED16 = 13,
  SFIXED32 = 14,
  UFIXED4 = 15,
  UFIXED8 = 16,
  UFIXED16 = 17,
  UFIXED32 = 18,
  BOOL = 19,
  STRING = 20,
  UNDEFINED = 21,
  MIN = INT8,
  MAX = UNDEFINED
};

inline const DataType (&EnumValuesDataType())[22] {
  static const DataType values[] = {
    DataType::INT8,
    DataType::INT16,
    DataType::INT32,
    DataType::INT64,
    DataType::UINT8,
    DataType::UINT16,
    DataType::UINT32,
    DataType::UINT64,
    DataType::FLOAT16,
    DataType::FLOAT32,
    DataType::FLOAT64,
    DataType::SFIXED4,
    DataType::SFIXED8,
    DataType::SFIXED16,
    DataType::SFIXED32,
    DataType::UFIXED4,
    DataType::UFIXED8,
    DataType::UFIXED16,
    DataType::UFIXED32,
    DataType::BOOL,
    DataType::STRING,
    DataType::UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesDataType() {
  static const char * const names[23] = {
    "INT8",
    "INT16",
    "INT32",
    "INT64",
    "UINT8",
    "UINT16",
    "UINT32",
    "UINT64",
    "FLOAT16",
    "FLOAT32",
    "FLOAT64",
    "SFIXED4",
    "SFIXED8",
    "SFIXED16",
    "SFIXED32",
    "UFIXED4",
    "UFIXED8",
    "UFIXED16",
    "UFIXED32",
    "BOOL",
    "STRING",
    "UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameDataType(DataType e) {
  if (::flatbuffers::IsOutRange(e, DataType::INT8, DataType::UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDataType()[index];
}

enum class QuantizeDef : int8_t {
  IMPL_GENERATED = 0,
  DEFINED = 1,
  UNDEFINED = 2,
  MIN = IMPL_GENERATED,
  MAX = UNDEFINED
};

inline const QuantizeDef (&EnumValuesQuantizeDef())[3] {
  static const QuantizeDef values[] = {
    QuantizeDef::IMPL_GENERATED,
    QuantizeDef::DEFINED,
    QuantizeDef::UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesQuantizeDef() {
  static const char * const names[4] = {
    "IMPL_GENERATED",
    "DEFINED",
    "UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizeDef(QuantizeDef e) {
  if (::flatbuffers::IsOutRange(e, QuantizeDef::IMPL_GENERATED, QuantizeDef::UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizeDef()[index];
}

enum class QuantizeType : int8_t {
  SCALE_OFFSET = 0,
  AXIS_SCALE_OFFSET = 1,
  BW_SCALE_OFFSET = 2,
  BW_AXIS_SCALE_OFFSET = 3,
  UNDEFINED = 4,
  MIN = SCALE_OFFSET,
  MAX = UNDEFINED
};

inline const QuantizeType (&EnumValuesQuantizeType())[5] {
  static const QuantizeType values[] = {
    QuantizeType::SCALE_OFFSET,
    QuantizeType::AXIS_SCALE_OFFSET,
    QuantizeType::BW_SCALE_OFFSET,
    QuantizeType::BW_AXIS_SCALE_OFFSET,
    QuantizeType::UNDEFINED
  };
  return values;
}

inline const char * const *EnumNamesQuantizeType() {
  static const char * const names[6] = {
    "SCALE_OFFSET",
    "AXIS_SCALE_OFFSET",
    "BW_SCALE_OFFSET",
    "BW_AXIS_SCALE_OFFSET",
    "UNDEFINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantizeType(QuantizeType e) {
  if (::flatbuffers::IsOutRange(e, QuantizeType::SCALE_OFFSET, QuantizeType::UNDEFINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantizeType()[index];
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) ScaleOffset FLATBUFFERS_FINAL_CLASS {
 private:
  float scale_;
  int32_t offset_;

 public:
  ScaleOffset()
      : scale_(0),
        offset_(0) {
  }
  ScaleOffset(float _scale, int32_t _offset)
      : scale_(::flatbuffers::EndianScalar(_scale)),
        offset_(::flatbuffers::EndianScalar(_offset)) {
  }
  float scale() const {
    return ::flatbuffers::EndianScalar(scale_);
  }
  int32_t offset() const {
    return ::flatbuffers::EndianScalar(offset_);
  }
};
FLATBUFFERS_STRUCT_END(ScaleOffset, 8);

struct QuantizeParam FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef QuantizeParamBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEF = 4,
    VT_TYPE = 6,
    VT_BITWIDTH = 8,
    VT_AXIS = 10,
    VT_SCALES = 12,
    VT_OFFSETS = 14,
    VT_DATA = 16
  };
  qcir::QuantizeDef def() const {
    return static_cast<qcir::QuantizeDef>(GetField<int8_t>(VT_DEF, 0));
  }
  qcir::QuantizeType type() const {
    return static_cast<qcir::QuantizeType>(GetField<int8_t>(VT_TYPE, 0));
  }
  uint32_t bitwidth() const {
    return GetField<uint32_t>(VT_BITWIDTH, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  const ::flatbuffers::Vector<float> *scales() const {
    return GetPointer<const ::flatbuffers::Vector<float> *>(VT_SCALES);
  }
  const ::flatbuffers::Vector<int32_t> *offsets() const {
    return GetPointer<const ::flatbuffers::Vector<int32_t> *>(VT_OFFSETS);
  }
  const ::flatbuffers::Vector<const qcir::ScaleOffset *> *data() const {
    return GetPointer<const ::flatbuffers::Vector<const qcir::ScaleOffset *> *>(VT_DATA);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_DEF, 1) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<uint32_t>(verifier, VT_BITWIDTH, 4) &&
           VerifyField<int32_t>(verifier, VT_AXIS, 4) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           verifier.EndTable();
  }
};

struct QuantizeParamBuilder {
  typedef QuantizeParam Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_def(qcir::QuantizeDef def) {
    fbb_.AddElement<int8_t>(QuantizeParam::VT_DEF, static_cast<int8_t>(def), 0);
  }
  void add_type(qcir::QuantizeType type) {
    fbb_.AddElement<int8_t>(QuantizeParam::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_bitwidth(uint32_t bitwidth) {
    fbb_.AddElement<uint32_t>(QuantizeParam::VT_BITWIDTH, bitwidth, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(QuantizeParam::VT_AXIS, axis, 0);
  }
  void add_scales(::flatbuffers::Offset<::flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(QuantizeParam::VT_SCALES, scales);
  }
  void add_offsets(::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> offsets) {
    fbb_.AddOffset(QuantizeParam::VT_OFFSETS, offsets);
  }
  void add_data(::flatbuffers::Offset<::flatbuffers::Vector<const qcir::ScaleOffset *>> data) {
    fbb_.AddOffset(QuantizeParam::VT_DATA, data);
  }
  explicit QuantizeParamBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<QuantizeParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<QuantizeParam>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<QuantizeParam> CreateQuantizeParam(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    qcir::QuantizeDef def = qcir::QuantizeDef::IMPL_GENERATED,
    qcir::QuantizeType type = qcir::QuantizeType::SCALE_OFFSET,
    uint32_t bitwidth = 0,
    int32_t axis = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<float>> scales = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<int32_t>> offsets = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<const qcir::ScaleOffset *>> data = 0) {
  QuantizeParamBuilder builder_(_fbb);
  builder_.add_data(data);
  builder_.add_offsets(offsets);
  builder_.add_scales(scales);
  builder_.add_axis(axis);
  builder_.add_bitwidth(bitwidth);
  builder_.add_type(type);
  builder_.add_def(def);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<QuantizeParam> CreateQuantizeParamDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    qcir::QuantizeDef def = qcir::QuantizeDef::IMPL_GENERATED,
    qcir::QuantizeType type = qcir::QuantizeType::SCALE_OFFSET,
    uint32_t bitwidth = 0,
    int32_t axis = 0,
    const std::vector<float> *scales = nullptr,
    const std::vector<int32_t> *offsets = nullptr,
    const std::vector<qcir::ScaleOffset> *data = nullptr) {
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  auto offsets__ = offsets ? _fbb.CreateVector<int32_t>(*offsets) : 0;
  auto data__ = data ? _fbb.CreateVectorOfStructs<qcir::ScaleOffset>(*data) : 0;
  return qcir::CreateQuantizeParam(
      _fbb,
      def,
      type,
      bitwidth,
      axis,
      scales__,
      offsets__,
      data__);
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_SHAPE = 6,
    VT_TYPE = 8,
    VT_DTYPE = 10,
    VT_QPARAM = 12,
    VT_SIZE = 14,
    VT_OFFSET = 16
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<uint32_t> *shape() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_SHAPE);
  }
  qcir::TensorType type() const {
    return static_cast<qcir::TensorType>(GetField<int8_t>(VT_TYPE, 0));
  }
  qcir::DataType dtype() const {
    return static_cast<qcir::DataType>(GetField<int8_t>(VT_DTYPE, 0));
  }
  const qcir::QuantizeParam *qparam() const {
    return GetPointer<const qcir::QuantizeParam *>(VT_QPARAM);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint64_t offset() const {
    return GetField<uint64_t>(VT_OFFSET, 0);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<int8_t>(verifier, VT_TYPE, 1) &&
           VerifyField<int8_t>(verifier, VT_DTYPE, 1) &&
           VerifyOffset(verifier, VT_QPARAM) &&
           verifier.VerifyTable(qparam()) &&
           VerifyField<uint32_t>(verifier, VT_SIZE, 4) &&
           VerifyField<uint64_t>(verifier, VT_OFFSET, 8) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  void add_shape(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_type(qcir::TensorType type) {
    fbb_.AddElement<int8_t>(Tensor::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_dtype(qcir::DataType dtype) {
    fbb_.AddElement<int8_t>(Tensor::VT_DTYPE, static_cast<int8_t>(dtype), 0);
  }
  void add_qparam(::flatbuffers::Offset<qcir::QuantizeParam> qparam) {
    fbb_.AddOffset(Tensor::VT_QPARAM, qparam);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Tensor::VT_SIZE, size, 0);
  }
  void add_offset(uint64_t offset) {
    fbb_.AddElement<uint64_t>(Tensor::VT_OFFSET, offset, 0);
  }
  explicit TensorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Tensor> CreateTensor(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> shape = 0,
    qcir::TensorType type = qcir::TensorType::WRITE,
    qcir::DataType dtype = qcir::DataType::INT8,
    ::flatbuffers::Offset<qcir::QuantizeParam> qparam = 0,
    uint32_t size = 0,
    uint64_t offset = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_size(size);
  builder_.add_qparam(qparam);
  builder_.add_shape(shape);
  builder_.add_name(name);
  builder_.add_dtype(dtype);
  builder_.add_type(type);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Tensor> CreateTensorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *shape = nullptr,
    qcir::TensorType type = qcir::TensorType::WRITE,
    qcir::DataType dtype = qcir::DataType::INT8,
    ::flatbuffers::Offset<qcir::QuantizeParam> qparam = 0,
    uint32_t size = 0,
    uint64_t offset = 0) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto shape__ = shape ? _fbb.CreateVector<uint32_t>(*shape) : 0;
  return qcir::CreateTensor(
      _fbb,
      name__,
      shape__,
      type,
      dtype,
      qparam,
      size,
      offset);
}

struct Operator FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef OperatorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_PACKAGE_NAME = 6,
    VT_TYPE_NAME = 8,
    VT_INPUTS = 10,
    VT_OUTPUTS = 12,
    VT_PARAMS = 14
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::String *package_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_PACKAGE_NAME);
  }
  const ::flatbuffers::String *type_name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_TYPE_NAME);
  }
  const ::flatbuffers::Vector<uint32_t> *inputs() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_INPUTS);
  }
  const ::flatbuffers::Vector<uint32_t> *outputs() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_OUTPUTS);
  }
  const ::flatbuffers::Vector<uint32_t> *params() const {
    return GetPointer<const ::flatbuffers::Vector<uint32_t> *>(VT_PARAMS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_PACKAGE_NAME) &&
           verifier.VerifyString(package_name()) &&
           VerifyOffset(verifier, VT_TYPE_NAME) &&
           verifier.VerifyString(type_name()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           VerifyOffset(verifier, VT_PARAMS) &&
           verifier.VerifyVector(params()) &&
           verifier.EndTable();
  }
};

struct OperatorBuilder {
  typedef Operator Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Operator::VT_NAME, name);
  }
  void add_package_name(::flatbuffers::Offset<::flatbuffers::String> package_name) {
    fbb_.AddOffset(Operator::VT_PACKAGE_NAME, package_name);
  }
  void add_type_name(::flatbuffers::Offset<::flatbuffers::String> type_name) {
    fbb_.AddOffset(Operator::VT_TYPE_NAME, type_name);
  }
  void add_inputs(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> inputs) {
    fbb_.AddOffset(Operator::VT_INPUTS, inputs);
  }
  void add_outputs(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> outputs) {
    fbb_.AddOffset(Operator::VT_OUTPUTS, outputs);
  }
  void add_params(::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> params) {
    fbb_.AddOffset(Operator::VT_PARAMS, params);
  }
  explicit OperatorBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Operator> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Operator>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Operator> CreateOperator(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> package_name = 0,
    ::flatbuffers::Offset<::flatbuffers::String> type_name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> inputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> outputs = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<uint32_t>> params = 0) {
  OperatorBuilder builder_(_fbb);
  builder_.add_params(params);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_type_name(type_name);
  builder_.add_package_name(package_name);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Operator> CreateOperatorDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *package_name = nullptr,
    const char *type_name = nullptr,
    const std::vector<uint32_t> *inputs = nullptr,
    const std::vector<uint32_t> *outputs = nullptr,
    const std::vector<uint32_t> *params = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto package_name__ = package_name ? _fbb.CreateString(package_name) : 0;
  auto type_name__ = type_name ? _fbb.CreateString(type_name) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<uint32_t>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<uint32_t>(*outputs) : 0;
  auto params__ = params ? _fbb.CreateVector<uint32_t>(*params) : 0;
  return qcir::CreateOperator(
      _fbb,
      name__,
      package_name__,
      type_name__,
      inputs__,
      outputs__,
      params__);
}

struct Graph FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef GraphBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODES = 6,
    VT_TENSORS = 8
  };
  const ::flatbuffers::String *name() const {
    return GetPointer<const ::flatbuffers::String *>(VT_NAME);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Operator>> *nodes() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Operator>> *>(VT_NODES);
  }
  const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Tensor>> *tensors() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Tensor>> *>(VT_TENSORS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_TENSORS) &&
           verifier.VerifyVector(tensors()) &&
           verifier.VerifyVectorOfTables(tensors()) &&
           verifier.EndTable();
  }
};

struct GraphBuilder {
  typedef Graph Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_name(::flatbuffers::Offset<::flatbuffers::String> name) {
    fbb_.AddOffset(Graph::VT_NAME, name);
  }
  void add_nodes(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Operator>>> nodes) {
    fbb_.AddOffset(Graph::VT_NODES, nodes);
  }
  void add_tensors(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Tensor>>> tensors) {
    fbb_.AddOffset(Graph::VT_TENSORS, tensors);
  }
  explicit GraphBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Graph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Graph>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Graph> CreateGraph(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::String> name = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Operator>>> nodes = 0,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Tensor>>> tensors = 0) {
  GraphBuilder builder_(_fbb);
  builder_.add_tensors(tensors);
  builder_.add_nodes(nodes);
  builder_.add_name(name);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Graph> CreateGraphDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<::flatbuffers::Offset<qcir::Operator>> *nodes = nullptr,
    const std::vector<::flatbuffers::Offset<qcir::Tensor>> *tensors = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<::flatbuffers::Offset<qcir::Operator>>(*nodes) : 0;
  auto tensors__ = tensors ? _fbb.CreateVector<::flatbuffers::Offset<qcir::Tensor>>(*tensors) : 0;
  return qcir::CreateGraph(
      _fbb,
      name__,
      nodes__,
      tensors__);
}

struct Context FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef ContextBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRAPHS = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Graph>> *graphs() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<qcir::Graph>> *>(VT_GRAPHS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_GRAPHS) &&
           verifier.VerifyVector(graphs()) &&
           verifier.VerifyVectorOfTables(graphs()) &&
           verifier.EndTable();
  }
};

struct ContextBuilder {
  typedef Context Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_graphs(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Graph>>> graphs) {
    fbb_.AddOffset(Context::VT_GRAPHS, graphs);
  }
  explicit ContextBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<Context> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<Context>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<Context> CreateContext(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<qcir::Graph>>> graphs = 0) {
  ContextBuilder builder_(_fbb);
  builder_.add_graphs(graphs);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<Context> CreateContextDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<qcir::Graph>> *graphs = nullptr) {
  auto graphs__ = graphs ? _fbb.CreateVector<::flatbuffers::Offset<qcir::Graph>>(*graphs) : 0;
  return qcir::CreateContext(
      _fbb,
      graphs__);
}

inline const qcir::Context *GetContext(const void *buf) {
  return ::flatbuffers::GetRoot<qcir::Context>(buf);
}

inline const qcir::Context *GetSizePrefixedContext(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<qcir::Context>(buf);
}

inline bool VerifyContextBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<qcir::Context>(nullptr);
}

inline bool VerifySizePrefixedContextBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<qcir::Context>(nullptr);
}

inline void FinishContextBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<qcir::Context> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedContextBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<qcir::Context> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace qcir

#endif  // FLATBUFFERS_GENERATED_QCIR_QCIR_H_
